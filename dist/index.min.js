const t={},e=[(t,e)=>t[e],(t,e)=>t.hasAttribute(e),(t,e)=>t.getAttribute(e),t=>1];class s extends WeakMap{use=(t,e={})=>this.get(t)||this.set(t,e).get(t)}const i=new s,n=new s,a=new s,o=(t,e)=>"number"===e?0|t:t;export class Signal{#t;#e=[];#s=0;constructor(t){this.#t=t}#i=()=>1==++this.#s&&queueMicrotask((()=>{this.#e.map((t=>t())),this.#s=0}));get value(){return this.#t}set value(t){this.#t=t,this.#i()}onChange(t,e){e&&t(this.#t),this.#e.push((()=>t(this.#t)))}when(t,e=[]){let s=new Signal(t(this.#t));return this.onChange((e=>s.value=t(e))),e.map((t=>t.onChange(this.#i))),s}}class l extends HTMLElement{#n=(t,e=this)=>e.getAttribute(t);#a=(t,s)=>{let i=t[0],a=t.slice(1),o=this.#n(t,s),l=".?!@".indexOf(i);if(l>=0){const i=e[l](s,a);n.use(s)[t]={init:i,name:o},queueMicrotask((()=>s.removeAttribute(t)))}};static#o={};static Signal=Signal;static hydrate=(e,s,o)=>{for(let h of e){const e=document.querySelector(h).shadowRoot,c=a.get(e)||t;for(let a in s){const h=i.get(e)[a],u=n.get(h);if(!u)continue;const r=s[a];for(let e in r){let s=r[e];e in l.#o&&(s=l.#o[e](s));const{name:i,init:n}=u[e.toLowerCase()]||t,{signal:a,type:g,id:d}=i&&c[i]||t;o instanceof Object&&d&&a&&(o[d]=a);const m=e.slice(1),p=t=>s({type:g,name:m,signal:a,signals:c,init:n,domNode:h,e:t});i&&(e.startsWith("@")?h.addEventListener(m,p):queueMicrotask(p))}}}};static plugin=(t,e)=>l.#o[t]=e;static rerender=({signal:t,name:e,domNode:s},i=!0)=>t.onChange((t=>s[e]=t),i);static render=t=>({domNode:e,name:s})=>e[s]="function"==typeof t?t():t;connectedCallback(){const t=this[this.#n("for")||"parentNode"],e=this.getRootNode(),s=this.#n("new"),n=s||this.#n("ref"),l=this.#n("type"),{id:h,textContent:c}=this;i.use(e)[n]=t,s&&(a.use(e)[n]={signal:new Signal(o(c,l)),type:l,id:h});for(let e of t.getAttributeNames())this.#a(e,t);this.className||this.replaceWith(c)}}customElements.define("sig-nal",l);
