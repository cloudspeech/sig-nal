const t={},e=[(t,e)=>t[e],(t,e)=>t.hasAttribute(e),(t,e)=>t.getAttribute(e),t=>1];class s extends WeakMap{use=(t,e={})=>this.get(t)||this.set(t,e).get(t)}const i=new s,n=new s,a=new s,o=(t,e)=>"number"===e?0|t:t;export class Signal{#t;#e=[];#s=0;constructor(t){this.#t=t}#i=()=>1==++this.#s&&queueMicrotask((()=>{this.#e.map((t=>t())),this.#s=0}));get value(){return this.#t}set value(t){this.#t=t,this.#i()}onChange(t,e){e&&t(this.#t),this.#e.push((()=>t(this.#t)))}when(t,e=[]){let s=new Signal(t(this.#t));return this.onChange((e=>s.value=t(e))),e.forEach((t=>t.when(this.#i))),s}}class h extends HTMLElement{#n=(t,e=this)=>e.getAttribute(t);#a=(t,s)=>{let i=t[0],a=t.slice(1),o=this.#n(t,s),h=".?!@".indexOf(i);if(h>=0){const i=e[h](s,a);n.use(s)[t]={init:i,name:o},queueMicrotask((()=>s.removeAttribute(t)))}};static#o={};static Signal=Signal;static hydrate=(e,s,o)=>{for(let l of e){const e=document.querySelector(l).shadowRoot,c=a.get(e)||t;for(let a in s){const l=i.get(e)[a],r=n.get(l);if(!r)continue;const u=s[a];for(let e in u){let s=u[e];e in h.#o&&(s=h.#o[e](s));const{name:i,init:n}=r[e.toLowerCase()]||t,{signal:a,type:g,id:d}=i&&c[i]||t;o instanceof Object&&d&&a&&(o[d]=a);const m=e.slice(1),f=t=>s({type:g,name:m,signal:a,signals:c,init:n,domNode:l,e:t});i&&(e.startsWith("@")?l.addEventListener(m,f):queueMicrotask(f))}}}};static plugin=(t,e)=>h.#o[t]=e;static rerender=({signal:t,name:e,domNode:s},i=!0)=>t.onChange((t=>s[e]=t),i);static render=t=>({domNode:e,name:s})=>e[s]="function"==typeof t?t():t;connectedCallback(){const t=this[this.#n("for")||"parentNode"],e=this.getRootNode(),s=this.#n("new"),n=s||this.#n("ref"),h=this.#n("type"),{id:l,textContent:c}=this;i.use(e)[n]=t,s&&(a.use(e)[n]={signal:new Signal(o(c,h)),type:h,id:l});for(let e of t.getAttributeNames())this.#a(e,t);this.className||this.replaceWith(c)}}customElements.define("sig-nal",h);
